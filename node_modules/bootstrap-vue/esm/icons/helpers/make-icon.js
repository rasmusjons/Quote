function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import Vue from '../../utils/vue';
import { mergeData } from 'vue-functional-data-merge';
import identity from '../../utils/identity';
import { kebabCase, pascalCase, trim } from '../../utils/string';
import { toFloat } from '../../utils/number'; // Common icon props (should be cloned/spread before using)

export var commonIconProps = {
  variant: {
    type: String,
    default: null
  },
  fontScale: {
    type: [Number, String],
    default: 1
  },
  scale: {
    type: [Number, String],
    default: 1
  },
  rotate: {
    type: [Number, String],
    default: 0
  },
  flipH: {
    type: Boolean,
    default: false
  },
  flipV: {
    type: Boolean,
    default: false
  },
  shiftH: {
    type: [Number, String],
    default: 0
  },
  shiftV: {
    type: [Number, String],
    default: 0
  }
}; // Base attributes needed on all icons

var baseAttrs = {
  width: '1em',
  height: '1em',
  viewBox: '0 0 20 20',
  focusable: 'false',
  role: 'img',
  alt: 'icon'
}; // Shared private base component to reduce bundle/runtime size
// @vue/component

var BVIconBase = {
  name: 'BVIconBase',
  functional: true,
  props: _objectSpread({
    content: {
      type: String
    }
  }, commonIconProps),
  render: function render(h, _ref) {
    var data = _ref.data,
        props = _ref.props;
    var fontScale = toFloat(props.fontScale) || 1;
    var scale = toFloat(props.scale) || 1;
    var rotate = toFloat(props.rotate) || 0;
    var shiftH = toFloat(props.shiftH) || 0;
    var shiftV = toFloat(props.shiftV) || 0;
    var flipH = props.flipH;
    var flipV = props.flipV; // Compute the transforms. Note that order is important
    // CSS transforms are applied in order from right to left
    // and we want flipping to occur before rotation, and
    // shifting is applied last

    var transforms = [shiftH ? "translateX(".concat(100 * shiftH / 16, "%)") : null, shiftV ? "translateY(".concat(-100 * shiftV / 16, "%)") : null, rotate ? "rotate(".concat(rotate, "deg)") : null, flipH || flipV || scale !== 1 ? "scale(".concat((flipH ? -1 : 1) * scale, ", ").concat((flipV ? -1 : 1) * scale, ")") : null].filter(identity); // We wrap the content in a `<g>` for handling the transforms

    var $inner = h('g', {
      style: {
        transform: transforms.join(' ') || null,
        transformOrigin: transforms.length > 0 ? 'center' : null
      },
      domProps: {
        innerHTML: props.content || ''
      }
    });
    return h('svg', mergeData({
      class: _defineProperty({}, "text-".concat(props.variant), !!props.variant),
      attrs: baseAttrs,
      style: {
        fontSize: fontScale === 1 ? null : "".concat(fontScale * 100, "%")
      }
    }, // Merge in user supplied data
    data, // These cannot be overridden by users
    {
      staticClass: 'b-icon bi',
      attrs: {
        xmlns: 'http://www.w3.org/2000/svg',
        fill: 'currentColor'
      }
    }), [$inner]);
  }
};
/**
 * Icon component generator function
 *
 * @param {string} icon name (minus the leading `BIcon`)
 * @param {string} raw innerHTML for SVG
 * @return {VueComponent}
 */

export var makeIcon = function makeIcon(name, content) {
  // For performance reason we pre-compute some values, so that
  // they are not computed on each render of the icon component
  var iconName = "BIcon".concat(pascalCase(name));
  var iconNameClass = "bi-".concat(kebabCase(name));
  var svgContent = trim(content || ''); // Return the icon component definition

  return Vue.extend({
    name: iconName,
    functional: true,
    props: _objectSpread({}, commonIconProps),
    render: function render(h, _ref2) {
      var data = _ref2.data,
          props = _ref2.props;
      return h(BVIconBase, mergeData(data, {
        staticClass: iconNameClass,
        props: _objectSpread({}, props, {
          content: svgContent
        })
      }));
    }
  });
};